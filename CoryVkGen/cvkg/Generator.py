from .SpecParser import SpecParser
from .EnumFmtGenerator import EnumFmtGenerator
from .StructFmtGenerator import StructFmtGenerator
from .BuilderGenerator import BuilderGenerator
from .GeneratorUtils import camel_to_snake
from Cheetah.Template import Template

import os
import os.path


class Generator:
    def __init__(self, registry: SpecParser, template_dir: str):
        self.registry = registry
        self.template_dir = template_dir

    def generate(self, output_dir: str):
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        create_infos = [c for c in self.registry.types.values() if not c.alias and "CreateInfo" in c.name]
        env = {
            'registry': self.registry,
            'create_infos': create_infos[:20],
            'camel_to_snake': camel_to_snake,
        }

        generators = [
            EnumFmtGenerator(self.registry, self.template_dir, output_dir),
            StructFmtGenerator(self.registry, self.template_dir, output_dir),
            BuilderGenerator(self.registry, self.template_dir, output_dir),
        ]

        # run all generators
        generated_files = []
        for generator in generators:
            generated_files += generator.run(output_dir, self.registry, env)

        print("#### Generated files:")
        for file in generated_files:
            # os.system(f'clang-format -i {file}')
            print(file)

        # write a .gitgnore and a cmake file
        def clean_file(f: str):
            return os.path.relpath(f, output_dir).replace('\\', '/')
        relative_files = [clean_file(file) for file in generated_files]
        sl = [{'generated_sources': [f for f in relative_files if f.endswith(".cpp")],
               'generated_headers': [f for f in relative_files if f.endswith(".h")]}]

        # load template
        gitignore_tpl = Template(searchList=sl, source="""
# gitignore file itself is autogenerated
.gitignore
# these files are also autogenerated and should not be checked in
GeneratedFiles.cmake
#for f in $generated_sources + $generated_headers
$f
#end for
        """)
        with open(os.path.join(output_dir, ".gitignore"), 'w') as f:
            f.write(str(gitignore_tpl))

        # load template
        cmake_output_tpl = Template(searchList=sl, source="""
# list of cvk files autogenerated by CoryVkGen 
set(CVK_GENERATED_SOURCES
#for f in $generated_sources
    $f
#end for
)
set(CVK_GENERATED_HEADERS
#for f in $generated_headers
    $f
#end for
)
set(CVK_GENERATED_FILES \${CVK_GENERATED_SOURCES} \${CVK_GENERATED_HEADERS})
        """)
        with open(os.path.join(output_dir, "GeneratedFiles.cmake"), 'w') as f:
            f.write(str(cmake_output_tpl))

        # for file in os.listdir(self.template_dir):
        #     template_path = os.path.join(self.template_dir, file)
        #     # only generate direct outputs for templates for .cpp or .h files
        #     if file.endswith('.h') or file.endswith('.cpp'):
        #         out_file = os.path.join(output_dir, file.replace('.tpl', ''))
        #         #template = loader.load_template(file)
        #         template = Template(file=template_path, searchList=[env,{'current_file': file}])
        #         with open(out_file, 'w') as f:
        #             #instantiated_template = template.merge(env, loader)
        #             instantiated_template = str(template)
        #             f.write(instantiated_template)
        #
        #         os.system(f'clang-format -i {out_file}')
        #         print(f"Generated {out_file}")
